// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const changeTicketsStatus = `-- name: ChangeTicketsStatus :exec
UPDATE ticket
    SET status = $1
WHERE id = $2
`

type ChangeTicketsStatusParams struct {
	Status   TicketStatus
	TicketID pgtype.UUID
}

func (q *Queries) ChangeTicketsStatus(ctx context.Context, arg ChangeTicketsStatusParams) error {
	_, err := q.db.Exec(ctx, changeTicketsStatus, arg.Status, arg.TicketID)
	return err
}

const deleteAttendee = `-- name: DeleteAttendee :exec
DELETE FROM attendee
WHERE id = $1
`

func (q *Queries) DeleteAttendee(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAttendee, id)
	return err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM event
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payment
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const deleteTicket = `-- name: DeleteTicket :exec
DELETE FROM ticket
WHERE id = $1
`

func (q *Queries) DeleteTicket(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTicket, id)
	return err
}

const getAvailableTickets = `-- name: GetAvailableTickets :many
SELECT
    id,
    name,
    price,
    COUNT(name) AS count
FROM ticket
WHERE status = 'available' AND name = $1
GROUP BY id
LIMIT $2
`

type GetAvailableTicketsParams struct {
	Name   string
	Limits int32
}

type GetAvailableTicketsRow struct {
	ID    pgtype.UUID
	Name  string
	Price string
	Count int64
}

func (q *Queries) GetAvailableTickets(ctx context.Context, arg GetAvailableTicketsParams) ([]GetAvailableTicketsRow, error) {
	rows, err := q.db.Query(ctx, getAvailableTickets, arg.Name, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailableTicketsRow
	for rows.Next() {
		var i GetAvailableTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Price,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvent = `-- name: GetEvent :one
SELECT
    e.id,
    e.name,
    e.description,
    e.location,
    e.event_start_date,
    e.event_end_date,
    e.created_at,
    e.updated_at,
    eti.inputs as ticket_inputs
FROM event e
LEFT JOIN ticket_inputs eti ON e.id = eti.event_id
WHERE e.id = $1
`

type GetEventRow struct {
	ID             pgtype.UUID
	Name           string
	Description    string
	Location       string
	EventStartDate pgtype.Timestamptz
	EventEndDate   pgtype.Timestamptz
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	TicketInputs   []byte
}

func (q *Queries) GetEvent(ctx context.Context, id pgtype.UUID) (GetEventRow, error) {
	row := q.db.QueryRow(ctx, getEvent, id)
	var i GetEventRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Location,
		&i.EventStartDate,
		&i.EventEndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TicketInputs,
	)
	return i, err
}

const getPayment = `-- name: GetPayment :one
SELECT
    e.id,
    e.event_id,
    e.data,
    e.name,
    e.email,
    e.bill_link_id,
    e.created_at,
    e.updated_at
FROM payment e
WHERE e.id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Data,
		&i.Name,
		&i.Email,
		&i.BillLinkID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTicket = `-- name: GetTicket :one
SELECT
    id, event_id, name, description, price, benefits, status, created_at, updated_at
FROM ticket
WHERE id = $1
`

func (q *Queries) GetTicket(ctx context.Context, id pgtype.UUID) (Ticket, error) {
	row := q.db.QueryRow(ctx, getTicket, id)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.Description,
		&i.Price,
		&i.Benefits,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertAttendee = `-- name: InsertAttendee :one

INSERT INTO attendee
    (event_id, ticket_id, data)
VALUES
    ($1, $2, $3)
RETURNING id
`

type InsertAttendeeParams struct {
	EventID  pgtype.UUID
	TicketID pgtype.UUID
	Data     []byte
}

// ###############################################################
// Attendee
// ###############################################################
func (q *Queries) InsertAttendee(ctx context.Context, arg InsertAttendeeParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertAttendee, arg.EventID, arg.TicketID, arg.Data)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertEvent = `-- name: InsertEvent :one

INSERT INTO event
    (name, description, location, event_start_date, event_end_date)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertEventParams struct {
	Name           string
	Description    string
	Location       string
	EventStartDate pgtype.Timestamptz
	EventEndDate   pgtype.Timestamptz
}

// ###############################################################
// Event
// ###############################################################
func (q *Queries) InsertEvent(ctx context.Context, arg InsertEventParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertEvent,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.EventStartDate,
		arg.EventEndDate,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertEventTicketInput = `-- name: InsertEventTicketInput :one

INSERT INTO ticket_inputs
    (event_id, inputs)
VALUES
    ($1, $2)
RETURNING id
`

type InsertEventTicketInputParams struct {
	EventID pgtype.UUID
	Inputs  []byte
}

// ###############################################################
// TicketInputs
// ###############################################################
func (q *Queries) InsertEventTicketInput(ctx context.Context, arg InsertEventTicketInputParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertEventTicketInput, arg.EventID, arg.Inputs)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertPayment = `-- name: InsertPayment :one

INSERT INTO payment
    (event_id, data, name, email, bill_link_id)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertPaymentParams struct {
	EventID    pgtype.UUID
	Data       []byte
	Name       string
	Email      string
	BillLinkID int32
}

// ###############################################################
// Payment
// ###############################################################
func (q *Queries) InsertPayment(ctx context.Context, arg InsertPaymentParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertPayment,
		arg.EventID,
		arg.Data,
		arg.Name,
		arg.Email,
		arg.BillLinkID,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const insertTicket = `-- name: InsertTicket :one

INSERT INTO ticket
    (event_id, name, description, price, benefits)
VALUES
    ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertTicketParams struct {
	EventID     pgtype.UUID
	Name        string
	Description string
	Price       string
	Benefits    []byte
}

// ###############################################################
// Ticket
// ###############################################################
func (q *Queries) InsertTicket(ctx context.Context, arg InsertTicketParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, insertTicket,
		arg.EventID,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Benefits,
	)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const listAttendee = `-- name: ListAttendee :many
SELECT
    e.id,
    e.event_id,
    e.ticket_id,
    e.data,
    e.created_at,
    e.updated_at
FROM attendee e
WHERE e.event_id = $1
ORDER BY $2
OFFSET $3
LIMIT $4
`

type ListAttendeeParams struct {
	EventID pgtype.UUID
	OrderBy interface{}
	Offsets int32
	Limits  int32
}

type ListAttendeeRow struct {
	ID        pgtype.UUID
	EventID   pgtype.UUID
	TicketID  pgtype.UUID
	Data      []byte
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

func (q *Queries) ListAttendee(ctx context.Context, arg ListAttendeeParams) ([]ListAttendeeRow, error) {
	rows, err := q.db.Query(ctx, listAttendee,
		arg.EventID,
		arg.OrderBy,
		arg.Offsets,
		arg.Limits,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAttendeeRow
	for rows.Next() {
		var i ListAttendeeRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.TicketID,
			&i.Data,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDistinctTicket = `-- name: ListDistinctTicket :many
SELECT DISTINCT ON (name)
    event_id,
    name,
    description,
    price,
    benefits,
    status,
    created_at,
    updated_at,
    COUNT(*) OVER (PARTITION BY name)
FROM ticket
WHERE event_id = $1 AND status = 'available'
ORDER BY name, created_at DESC
`

type ListDistinctTicketRow struct {
	EventID     pgtype.UUID
	Name        string
	Description string
	Price       string
	Benefits    []byte
	Status      TicketStatus
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	Count       int64
}

func (q *Queries) ListDistinctTicket(ctx context.Context, eventID pgtype.UUID) ([]ListDistinctTicketRow, error) {
	rows, err := q.db.Query(ctx, listDistinctTicket, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDistinctTicketRow
	for rows.Next() {
		var i ListDistinctTicketRow
		if err := rows.Scan(
			&i.EventID,
			&i.Name,
			&i.Description,
			&i.Price,
			&i.Benefits,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvent = `-- name: ListEvent :many
SELECT
    event.id,
    event.name,
    event.description,
    event.location,
    event.event_start_date,
    event.event_end_date,
    event.created_at,
    event.updated_at,
    ticket_inputs.inputs as ticket_inputs
FROM event
LEFT JOIN ticket_inputs ticket_inputs ON event.id = ticket_inputs.event_id
ORDER BY $1
OFFSET $2
LIMIT $3
`

type ListEventParams struct {
	OrderBy interface{}
	Offsets int32
	Limits  int32
}

type ListEventRow struct {
	ID             pgtype.UUID
	Name           string
	Description    string
	Location       string
	EventStartDate pgtype.Timestamptz
	EventEndDate   pgtype.Timestamptz
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
	TicketInputs   []byte
}

func (q *Queries) ListEvent(ctx context.Context, arg ListEventParams) ([]ListEventRow, error) {
	rows, err := q.db.Query(ctx, listEvent, arg.OrderBy, arg.Offsets, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListEventRow
	for rows.Next() {
		var i ListEventRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.EventStartDate,
			&i.EventEndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TicketInputs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayment = `-- name: ListPayment :many
SELECT
    e.id,
    e.event_id,
    e.data,
    e.name,
    e.email,
    e.bill_link_id,
    e.created_at,
    e.updated_at
FROM payment e
ORDER BY $1
OFFSET $2
LIMIT $3
`

type ListPaymentParams struct {
	OrderBy interface{}
	Offsets int32
	Limits  int32
}

func (q *Queries) ListPayment(ctx context.Context, arg ListPaymentParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPayment, arg.OrderBy, arg.Offsets, arg.Limits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Data,
			&i.Name,
			&i.Email,
			&i.BillLinkID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpcomingEvent = `-- name: ListUpcomingEvent :many
SELECT id, name, description, location, event_start_date, event_end_date, created_at, updated_at
FROM event
WHERE NOW() < event_start_date::date
ORDER BY event_start_date ASC
`

func (q *Queries) ListUpcomingEvent(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, listUpcomingEvent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Location,
			&i.EventStartDate,
			&i.EventEndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttendeeStatus = `-- name: UpdateAttendeeStatus :exec
UPDATE attendee
SET
    status = $1
WHERE id = $2
`

type UpdateAttendeeStatusParams struct {
	Status     AttendeeStatus
	AttendeeID pgtype.UUID
}

func (q *Queries) UpdateAttendeeStatus(ctx context.Context, arg UpdateAttendeeStatusParams) error {
	_, err := q.db.Exec(ctx, updateAttendeeStatus, arg.Status, arg.AttendeeID)
	return err
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE event
SET
    name = $1,
    description = $2,
    location = $3,
    event_start_date = $4,
    event_end_date = $5
WHERE id = $6
`

type UpdateEventParams struct {
	Name           string
	Description    string
	Location       string
	EventStartDate pgtype.Timestamptz
	EventEndDate   pgtype.Timestamptz
	EventID        pgtype.UUID
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent,
		arg.Name,
		arg.Description,
		arg.Location,
		arg.EventStartDate,
		arg.EventEndDate,
		arg.EventID,
	)
	return err
}

const updatePayment = `-- name: UpdatePayment :exec
UPDATE payment
SET
    data = $1,
    name = $2,
    email = $3,
    bill_link_id = $4
WHERE id = $5
`

type UpdatePaymentParams struct {
	Data       []byte
	Name       string
	Email      string
	BillLinkID int32
	PaymentID  pgtype.UUID
}

func (q *Queries) UpdatePayment(ctx context.Context, arg UpdatePaymentParams) error {
	_, err := q.db.Exec(ctx, updatePayment,
		arg.Data,
		arg.Name,
		arg.Email,
		arg.BillLinkID,
		arg.PaymentID,
	)
	return err
}

const updateTicket = `-- name: UpdateTicket :exec
UPDATE ticket
SET
    name = $1,
    description = $2,
    price = $3,
    benefits = $4
WHERE event_id = $5
`

type UpdateTicketParams struct {
	Name        string
	Description string
	Price       string
	Benefits    []byte
	EventID     pgtype.UUID
}

func (q *Queries) UpdateTicket(ctx context.Context, arg UpdateTicketParams) error {
	_, err := q.db.Exec(ctx, updateTicket,
		arg.Name,
		arg.Description,
		arg.Price,
		arg.Benefits,
		arg.EventID,
	)
	return err
}
